\documentclass[11pt]{article}

\usepackage{../style/ece361}

%-------------------------------------------------------------------------------------------------

% Lab parameters
\def\thelab{1}
\def\datedue{Feb. 1, 2020 @ 11:59 PM}

\useCompactTitle{ECE361 Lab \thelab}{Message Transfer}

%-------------------------------------------------------------------------------------------------
\begin{document}
% Create title page, and force header and footer onto it
\maketitle \thispagestyle{fancy}

\hfill {\large \textbf{Due \datedue}}
%-------------------------------------------------------------------------------------------------


%-------------------------------------------------------------------------------------------------
\section{Introduction}
\label{sec:introduction}
%-------------------------------------------------------------------------------------------------
A network address is a logical (e.g., IP address) or physical address (e.g., MAC address) that uniquely distinguishes a network node from other nodes on the network. It is usually a number that is assigned to any device or network interface card that seeks access to be part of the network. A network node such as a personal computer or a mobile phone may also have several applications that use the node's connection to communicate with one another across the network. To distinguish the applications data from one another, the operating system allows applications to use port numbers. Therefore, each applications data will be mapped to a port number as consecutively they all can share the same network address to communicate on the network. By analogy, we can assume an apartment building that each unit has its own unit number, but they all share the same geographical address on the map.

To use a port number, applications are required to use a socket. A socket is one endpoint of a two-way communication link which is bound to a port number so that the transport layer protocols can identify the application that the data is destined to. Throughout this lab, we first learn how to use a socket to transmit data across the network and then we use our knowledge to build a simple file transfer application. We also see how headers are used to carry the network addresses and enable the network to guide the data message to any destination nodes.

%-------------------------------------------------------------------------------------------------
\subsection{Lab Structure}
\label{subsec:lab-structure}
%-------------------------------------------------------------------------------------------------
This lab consists of two important tracks. Each track has an important goal and a set of objectives that must be met to satisfy the goal. Please read the information below which explains the goal and objectives of each labs carefully and follow the steps that are involved to complete each objective.
%-------------------------------------------------------------------------------------------------


\subsection{Lab Initialization}
\label{subsec:lab-init}
%-------------------------------------------------------------------------------------------------
You first need to access the starter code that is provided to you and navigate to the network-layering directory. All the labs requirements including the \texttt{ece361} library are included in the starter code virtual environment which must be activated first. To activate the virtual environment, please open a terminal and run the following command line onto your open terminal.

\textbf{TLIN TODOOOOOOOOOOOOOOOOOOO}

Note that after the virtual environment is activated, you will see (.venv) is written before the input line on your terminal. The following is an example.



%-------------------------------------------------------------------------------------------------
\section{Track 1}
\label{sec:track1}
%-------------------------------------------------------------------------------------------------
This is a tutorial track which explains the use of network addresses and port numbers in guiding the applications data on the network. The goal of the track is to guide you on a step by step coding experiment that allows you to experience the importance of addressing as well as showing you how to work with the \texttt{ece361} library. You do not need to write codes for this track. You only need to follow the steps to fulfill the track objectives. This track follows four important objectives which are designed in the form of individual modules. You and your team members must follow the steps included in each module to complete its objective.

\textbf{Note:}
It is highly important you to first read the appendix that explains the \texttt{ece361} library and the \texttt{Socket()} class before you continue with this track.

%-------------------------------------------------------------------------------------------------
\subsection{Module 1}
\label{subsec:module1}
%-------------------------------------------------------------------------------------------------
This module objective is to demonstrate the use of broadcasting in exchanging data between the participating nodes. You need to open three terminals and follow the same steps again to activate the lab virtual environment and then follow the steps below.
\begin{enumerate}
    \item Navigate to lab1/track1 directory and open module1 on all your three open terminals.
    \item In each of the Python files provided, you need to replace the \texttt{<your\_student\_number>} with your student number for the following steps. This is very important as it may cause conflict with other students experiments. If you are working in team of two or more, use only one of the team members student ID in all the modules.
    \item You need to run an instance of the \texttt{receiver.py} and \texttt{receiver2.py} in two of the three open terminals. Run the instances by typing \texttt{python3 receiver.py} and \texttt{python3 receiver2.py} onto the command line of your terminals. Make sure to replace your student number on both files.
    \item Run an instance of the \texttt{sender.py} by typing \texttt{python3 sender.py} onto the command line of your open terminal. Make sure to replace your student number.
    \item Check if the receivers obtained the sender message and that the sender address is the same in both.
\end{enumerate}

\warn{You must make sure you run the receiver applications described in step 2 before you run the sender in step 3.}

\textbf{Note:}
The \texttt{From:} displays the sender address of the broadcast message. It is in the form of a list where the first element indicates the sender address on the network. It may be a random name that was chosen initially but, it is subject to change at any time. Notice that the sender's address is identical for both receivers. That is an indicator that the same message is received by all the receivers. The second element of the list indicates the port number of the sender node.
If you see "N/A" is shown on the list, that is in indication that the port number is not specified on the source (sender) node. As you also understood, if a message is broadcasted to every node on the network, you do not need to include any information about the message destination. That's why the \texttt{sendto()} function only requires the message as its input argument.

\think{Do you think broadcasting is an efficient way to transmit data between the participant nodes on the network?}

%-------------------------------------------------------------------------------------------------
\subsection{Module 2}
\label{subsec:module2}
%-------------------------------------------------------------------------------------------------
This module objective is to introduce the notion of destination address in sending data to specific nodes on the network. As you also noticed, broadcasting does not scale when the number of nodes on the network increases. Therefore, by using the destination address the network can find the target node on the network and delivers the data messages to that specific destination instead of broadcasting the message to all the nodes. To see how it works, follow the steps below to see an example.

\warn{Please do not forget to replace the \texttt{<your\_student\_number>} with your own student number and to make sure that the lab virtual environment has been activated as specified in module 1.}

\begin{enumerate}
    \item Navigate to lab1/track1 directory and open module 2 on all the terminal instances that you need to run for this module.
    \item Open your terminal and run an instance of the \texttt{receiver.py} by typing \texttt{python3 receiver.py} onto the command line of your open terminal.
    \item Open another terminal and run an instance of the \texttt{receiver2.py} by typing \texttt{python3 receiver2.py} onto the command line of your open terminal.
    \item Open another terminal and run an instance of the \texttt{sender.py} by typing \texttt{python3 sender.py} onto the command line of your open terminal.
\end{enumerate}

\warn{You must make sure you run the receiver applications described in step 2 before you run the sender in step 3.}

\think{As you can see, each of the receiver nodes will only receive the message that is destined to itself. Now imagine that each node in the network will have several applications running on the same node. How can we provide a mechanism so that each applications data can be distinguished from other applications?}


%-------------------------------------------------------------------------------------------------
\subsection{Module 3}
\label{subsec:module3}
%-------------------------------------------------------------------------------------------------
This module objective is to introduce the notion of port numbers to distinguish several applications data from each other and to allow them to use the nodes connection to communicate with each other across the network. To see how it works, follow the steps below to see an example.

\warn{Please do not forget to replace the \texttt{<your\_student\_number>} with your own student number and to make sure that the lab virtual environment has been activated as specified in module 1.}

\begin{enumerate}
    \item Navigate to lab1/track1 directory and open module 3 on all the terminal instances that you need to run for this module.
    \item Open a terminal and run an instance of the \texttt{receiver.py} by typing \texttt{python3 receiver.py} onto the command line of your open terminal.
    \item Open another terminal and run an instance of the \texttt{receiver2.py} by typing \texttt{python3 receiver.py} onto the command line of your open terminal.
    \item Open another terminal and run an instance of the \texttt{sender.py} by typing \texttt{python3 sender.py} onto the command line of your open terminal.
\end{enumerate}

As you can see, both receivers share the same address but, use a different port number. Consequently, each application receiver only receives the data messages that is destined to itself.

\think{Now, what if we need to communicate with the sender of the message. How can the receiver reply to the sender after it receives a message form it?}


%-------------------------------------------------------------------------------------------------
\subsection{Module 4}
\label{subsec:module4}
%-------------------------------------------------------------------------------------------------
This module objective is to introduce the notion of source address and how the receiver node can use this information to reply to the sender. To see how it works, follow the steps below to see an example.

\warn{Please do not forget to replace the \texttt{<your\_student\_number>} with your own student number and to make sure that the lab virtual environment has been activated as specified in module 1.}

\begin{enumerate}
    \item Navigate to lab1/track1 directory and open module 4 on all the terminal instances that you need to run for this module.
    \item Open a terminal and run an instance of the \texttt{receiver.py} by typing \texttt{python3 receiver.py} onto the command line of your open terminal.
    \item Open another terminal and run an instance of the \texttt{sender.py} by typing \texttt{python3 sender.py} onto the command line of your open terminal.
\end{enumerate}

As you can see, the sender's node application uses a port number to transmits a message that carries a \texttt{hi} to the destination node application that is bound to a specific port number. The receiver will also reply to that application by using the node address and the sender's application port number.

\textbf{Note:}
The receiver application can have access to the senders application port number and address via the \texttt{recvfrom()} return values. Please see the lab appendix for further information on how to use the \texttt{recvfrom()}.

%-------------------------------------------------------------------------------------------------
\section{Track 2}
\label{sec:track2}
%-------------------------------------------------------------------------------------------------
After showing different forms of transmitting data messages across the network, this track's goal is to ask you to complete a programming challenge that allows a sender application to open and read a file and send it to a destination receiver application, where the file will be reassembled and written on the disk.
To complete this assignment, you must navigate to lab1/track2 where the starter code is located.

\textbf{Note:}
The maximum amount of data that the sender can include in a message is 100 bytes. Therefore, the sender must divide the file into several file chunks of at most 100 bytes and then transfer them to the destination. The receiver will then receive each chunk and reassemble the file on the destination.

\warn{Please do not forget to replace the \texttt{<your\_student\_number>} with your own student number and to make sure that the lab virtual environment has been activated as specified in module 1.}

%-------------------------------------------------------------------------------------------------
\subsection{Objective 1}
\label{subsec:obj1}
%-------------------------------------------------------------------------------------------------
Writing the sender's application by completing the extracted parts of the \texttt{sender.py} source code. You need to complete the missing parts of the \texttt{send\_file()} function and replace the input arguments with your information as indicated in the lines 56-60. Even though the source code is commented to guide you with your programming assignment, the following checkpoints are important to keep in mind.
\begin{itemize}
    \item You can find the sender's application in the \texttt{sender.py} file.
    \item A text file named \texttt{iso.txt} is provided to you with the starter code. The \texttt{send\_file()} function must be able to open and read this file. Note that this is very important not to change the input argument for \texttt{file\_name} on both the sender and receiver applications.
    \item The sender must first get the size of the \texttt{iso.txt} file and send that information to the receiver.
    \item The receiver will then acknowledge the successful receipt of the file size by sending an "ACK" message. See the comments on the starter code on how to handle the acknowledgement messages.
    \item Upon successful transmission of the file size, the sender reads chunks of the file and send them sequentially to the receiver, until it reads to whole file.
    \item Each time the sender transmits a file chunk, the receiver must acknowledge the receipt of the message and sends back an acknowledgement to the sender. The sender can only transmit the next file chunk, if it receives an acknowledgement. See the comments on the starter code on how to handle the acknowledgement messages.
    \item After a successful execution of the sender application (\texttt{sender.py}), the application displays the file size that was transmitted as well as the number of file chunks (segments) that were sent to the receiver application.
\end{itemize}

\warn{You must first run the receiver application and then run the sender to test your code. Otherwise, it may not be successful in receiving all the file chunks.}

%-------------------------------------------------------------------------------------------------
\subsection{Objective 2}
\label{subsec:obj2}
%-------------------------------------------------------------------------------------------------
Writing the receiver's application by completing the extracted parts of the \texttt{receiver.py} source code. You need to complete the missing parts of the \texttt{receive\_file()} function and replace the input arguments with your information as specified in the lines 50-55. Even though the source code is commented to guide you with your programming assignment, the following checkpoints are important to keep in mind.

\begin{itemize}
    \item You can find the receiver's application in the \texttt{receiver.py} file.
    \item The receiver will create a file named \texttt{iso\_copy.txt} and write the incoming chunks into this file. This file name is used as an input argument when we call the \texttt{receive\_from} function. Please do not alter this name as we are aiming that everyone to experience the same sequence of events.
    \item The receiver is sending an acknowledgement message to the sender's application upon successful receipt of the file chunks. It also sends a "NACK" message which signals the sender to resend the same file chunk, if it wasn't successfully received. See the comments on the starter code on how to handle the acknowledgement messages.
    \item The receiver must first receive the file size from the sender's application and use that information to know how much of the data is received at a time.
    \item The receiver also uses this information to understand if the file transmission has been finished or not.
    \item After a successfully completing the starter-code, a successful execution of the receiver application (\texttt{receiver.py}) will write a file on the same directory which has the same size and content if the original file. The receiver application will also display the file size and the number of segments that has been received.
\end{itemize}

\warn{You must first run the receiver application and then run the sender to test your code. Otherwise, it may not be successful in receiving all the file chunks.}

\textbf{Note:}
The resulting file size and the number of transmitted segments must be the same on both sender and receiver applications.

\point{You may experience a small delay in the data transmission between the sender and receiver applications. If you see that, do not worry and do not stop your code. It is generally due to the fact that the network is shared between all the students and that may cause some delay. Please be patient as it will continue the transmission again.}

The following images demonstrate an example output after a successful execution of the receiver and sender applications.
\figvs{0.65}{t2-send-output}{trim=0cm 0cm 0cm 0cm,clip}{The output of the sender application (\texttt{sender.py})}
\figvs{0.9}{t2-recv-output}{trim=0cm 0cm 0cm 0cm,clip}{The output of the receiver application (\texttt{receiver.py})}


%-------------------------------------------------------------------------------------------------
\section{Exerciser}
\label{sec:exercise}
%-------------------------------------------------------------------------------------------------
\textbf{TODO}

%-------------------------------------------------------------------------------------------------
\section{Submission}
\label{sec:submission}
%-------------------------------------------------------------------------------------------------
\textbf{TODO}

\newpage
%-------------------------------------------------------------------------------------------------
\section{Appendix A: The \texttt{ece361} Python Library}
\label{sec:appendix-ece361-lib}
%-------------------------------------------------------------------------------------------------
The \texttt{ece361} library includes a networking package which implements an enhanced environment that allows the developers (students) to experiment various forms of end to end communications using network addresses. While the networking package offers the same programming features that you normally need to work with in real production, it offers more flexibility for to supporting the objectives followed by the course. As a result, you may need to seek for more information on network programming after you completed this lab assignment.

The networking package offered by \texttt{ece361} library provides an important class called \texttt{Socket} which you will learn how to use its method to create network applications in both track 1 and track 2 of this lab assignments. The following section will explain the \texttt{Socket} class and its functions in more details.

%-------------------------------------------------------------------------------------------------
\subsection{The \texttt{Socket} Class}
\label{subsec:socket-class}
%-------------------------------------------------------------------------------------------------
A network socket is one endpoint of a two-way communication link. The endpoint can be created by a software application through a programming language library that provides the required features. Therefore, to enable an application to communicate over the network, the application developer must create a socket to build an endpoint. The endpoint can be used to send and receive data from the network. In this lab environment, you can easily build a socket by importing \texttt{ece361} networking package and create an object of the class \texttt{Socket}. The following demonstrate an example of how you can achieve this. In addition, you can find informative examples by completing the track 1 tutorial modules.

\begin{lstlisting}[caption={Importing the \texttt{Socket} class}, language=Python]
from ece361.netowrk.socket import Socket

# In your code
socket_object_name = Socket(<Your Student Number>)
\end{lstlisting}

The class socket in the lab1 environment requires you to provide your student number. This is because of the fact that the lab environment will create a personal and customized network for you which makes your data messages and experiments invisible to others. Therefore, it is of utmost importance to provide your student number correctly. Member of a team are required to use one of the team members student ID.

\textbf{Note:}
If you use a student number to create a socket object, you must use it on every single instance of your objects to allow the endpoints to be part of the same network. For instance, if you have a sender and a receiver application that need to exchange data with each other, you need to create an instance of the socket object on both and provide the same student number as an input on both socket objects. This way, they belong to the same network. You can also see examples of this by completing the track 1 modules.

After creating a socket object, the object allows you to use the following methods to build your applications. Please read each method's manual to learn more about the function they provide to you.

%-------------------------------------------------------------------------------------------------
\subsubsection{\texttt{Socket.\textbf{change\_source\_address(address, port)}}}
%-------------------------------------------------------------------------------------------------
This method allows you to change the socket address and port number. The format of the input arguments is:
\begin{itemize}
    \item \texttt{address}: An IP address or any name in the format of string characters.
    \item \texttt{port}: A number or name in the format of string characters.
\end{itemize}

\begin{lstlisting}[caption={Example for using \texttt{change\_source\_address()}}, language=Python]
my_socket = Socket('1234567890')
my_socket.change_source_address(address='130.14.45.88', port='1221')
...
my_socket.change_source_address(address='ece361', port='app1')
\end{lstlisting}

\textbf{Note:}
Be advised that in the enhanced environment provided by the \texttt{ece361} library, when you create a socket object, it chooses a random address and port number as the source address. The initial port number is â€˜N/A' which indicates the socket does not use any port number. Therefore, the following items are important to keep in mind.
\begin{itemize}
    \item If you created a socket, the best practice is to change the address and port numbers value to your preferred choices to avoid confusion.
    \item Both address and port numbers must be provided in the string characters format. Please see the examples.
    \item The flexibility that you have to use a socket without specifying a port number is due to the environment characteristics that you work on. In real production environment, you must specify both the address and port numbers at the time of socket creation.
\end{itemize}

%-------------------------------------------------------------------------------------------------
\subsubsection{\texttt{Socket.\textbf{sendto(application\_data, dst\_address, dst\_port)}}}
%-------------------------------------------------------------------------------------------------
This method enables the application developers (students) to send data messages destination endpoints. The type of the input parameters are as follows:
\begin{itemize}
    \item \textbf{application\_data}: This parameter accepts string characters arguments.
    \item \textbf{dst\_address}: An IP address or any name in the format of string characters.
    \item \textbf{dst\_port}: A number or name in the format of string characters.
\end{itemize}

\textbf{Note:}
The \texttt{sendto()} function can carry application data which is less than or equal 100 bytes. It also return -1 if the data is larger than the maximum segment size or returns the length of the data that was successfully transmitted.

The \texttt{sendto()} method can be used in three ways.
\begin{enumerate}
    \item Without specifying a destination address and port number: This way the \texttt{sendto()} method broadcasts its data to every node on the network.
        \begin{lstlisting}[caption={}, language=Python]
my_socket.sendto(application_data)
        \end{lstlisting}

    \item Using a destination address without a port number: This approach can be used to send the data to a specific node on the network. However, if the name will be shared by several application receivers, they all will receive the message.
        \begin{lstlisting}[caption={}, language=Python]
my_socket.sendto(application_data='hi', dst_address='130.45.36.78')
        \end{lstlisting}

    \item Using both destination address and port number: This approach can be used to send the data to a specific application endpoint.
        \begin{lstlisting}[caption={}, language=Python]
my_socket.sendto(application_data='hi', dst_address='130.45.36.78', dst_port='app1')
        \end{lstlisting}
\end{enumerate}

\textbf{Note:}
To allow the receiver endpoint to receive the data message, the destination address and port numbers must match those of the receiver socket object. Therefore, you must first change the receiver source address and port number to any values of your choice before you send the data to the receiver. The new values can be used as the destination address on the \texttt{sendto()} method. Please complete the track 1 modules to see various examples of how to use your knowledge about the \texttt{sendto()} method in building your own applications.

%-------------------------------------------------------------------------------------------------
\subsubsection{\texttt{Socket.\textbf{recvfrom()}}}
%-------------------------------------------------------------------------------------------------
This method can be used to obtain the data messages from the network. The \texttt{recvfrom()} method does not require any input argument. If the method is used, it only receives the broadcast messages or the messages that are destined to this receiver.

\textbf{Note:}
The receiver endpoint is identifiable in the network it's the source address and port numbers. Therefore, if a message is sent to a receiver by only specifying the destination address, the receiver can obtain the message if the destination address matches the one on the receiver. The receiver will also check the port number only if it is provided as a part of the destination address on the \texttt{sendto()} method. Please complete the track 1 modules to see various examples of how \texttt{recvfrom()} method can be used to build your own applications.

\textbf{Note:}
The \texttt{recvfrom()} method will return the source (sender) address of the message as well as the message data. The address will be returned as a list where the first element is the sender's address and the second element is the sender's port number. Please note that if you send a broadcast message or a message without a destination port number, you may still receive the source address and port number. These values are either the sender's initial address and port number that are chosen at the time of the socket creation or are the values that have been set by the sender's application developer. In any case, you can use this information to get back to the sender, if necessary. Track 1 modules will show you how you can take the advantage of these information in building your own applications.

\begin{lstlisting}[caption={Example for using \texttt{recvfrom()}}, language=Python]
a, b = my_socket.recvfrom()
print(a) # [source address, source port]
print(b) # Message Data
\end{lstlisting}

%-------------------------------------------------------------------------------------------------
\subsubsection{\texttt{Socket.\textbf{display\_last\_header()}}}
%-------------------------------------------------------------------------------------------------
This method can be used to show the last sent message's header. When you use the \texttt{sendto()} method to send a message, the \texttt{sendto()} will create two data structures.
\begin{enumerate}
    \item \textbf{Message Header}: The header contains four pieces of data and is used to allow the network to navigate the messages to their destinations. The header contains the \texttt{[source\_address, source\_port, destination\_address, destination\_port]}. Therefore, by using this method you can always see the header of the last transmitted message.
    \item \textbf{Segment}: The segment includes both the header and the application data.
\end{enumerate}

\textbf{Note:}
This information in the header depends on the values of the source address and how the developer specify the destination receiver for the \texttt{sendto()} method. You can see an example of how to use this method by completing the track 1 module 4.

\begin{itemize}
    \item A message header
		% figvs takes 4 parameters (see the style sheet for source code)
		%   1) Image width (w.r.t. column)
		%   2) Image file name
		%   3) Other 'includegraphics' parameters
		%   4) Caption
		\figvs{0.9}{msg-header}{trim=0cm 0cm 0cm 0cm,clip}{A message header.}

    \item A message segment
		\figvs{0.7}{msg-segment}{trim=0cm 0cm 0cm 0cm,clip}{A message segment.}
\end{itemize}

\begin{lstlisting}[caption={Example for using \texttt{display\_last\_header()}}, language=Python]
my_socket.display_last_header()
\end{lstlisting}

%-------------------------------------------------------------------------------------------------
\subsubsection{\texttt{Socket.\textbf{display\_last\_segment()}}}
%-------------------------------------------------------------------------------------------------
The same as above, this method can be used to see the last segment content.

\textbf{Note:}
You can see an example of how to use this method by completing track 1 module 4.

\begin{lstlisting}[caption={Example for using \texttt{display\_last\_segment()}}, language=Python]
my_socket.display_last_segment()
\end{lstlisting}

\end{document}
