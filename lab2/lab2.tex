\documentclass[11pt]{article}

\usepackage{../style/ece361}

%-------------------------------------------------------------------------------------------------

% Lab parameters
\def\thelab{2}
\def\datedue{Feb. 18, 2020 @ 11:59 PM}

\useCompactTitle{ECE361 Lab \thelab}{Automatic Repeat Request (ARQ) Protocols}

%-------------------------------------------------------------------------------------------------
\begin{document}
% Create title page, and force header and footer onto it
\maketitle \thispagestyle{fancy}
\hfill {\large \textbf{Due \datedue}}
%-------------------------------------------------------------------------------------------------


%-------------------------------------------------------------------------------------------------
\section{Overview}
\label{sec:overview}
%-------------------------------------------------------------------------------------------------
In many applications reliable data transmission over an unreliable service is required. ARQ protocols are for exactly that. In this lab, you will be given 2 virtual hosts and an unreliable channel between them. With that you will first enhance the Stop-and-Wait protocol implemented in lab 1 to work on an unreliable channel. After that you will implement a better, more efficient sliding window protocol, in particular, the Send Many, Receive One protocol.

%-------------------------------------------------------------------------------------------------
\subsection{Lab Initialization}
\label{subsec:lab-init}
%-------------------------------------------------------------------------------------------------
This lab includes starter code that uses a custom-built Python 3 library called \texttt{ece361}. A Python virtual environment will be created, that will include the library, where you will do all the work in this lab. Virtual environments must be "activated" before you attempt to run the code inside. We have provided an initialization script for you that will setup this virtual environment, along with the starter code, and the custom library.

\hint{It's highly recommended to update your VM before starting each lab. Open a terminal (in the VM), and type \texttt{ece361-update}}

To run the initialization script for lab \thelab, open a terminal and type \texttt{ece361-lab-init \thelab}. You should see something similar to listing~\ref{lst:init-example}.
\begin{lstlisting}[style=ece361shell, caption={Initializing lab \thelab.}, label={lst:init-example}]
ubuntu@ece361:~$ ece361-lab-init (@"\thelab"@)
Finding available UG EECG host...
Warning: Permanently added 'ug251.eecg.utoronto.ca,128.100.13.251' (ECDSA) to the list of known hosts.
Creating working directory for lab (@"\thelab"@) at (@"\btHL /home/ubuntu/lab\thelab"@)
Creating Python3 virtual environment...
Installing libraries...

...

Done. Now run (@"\btHL source /home/ubuntu/lab\thelab/sourceMe"@) to activate the virtual environment.
\end{lstlisting}

The initialization script creates a working directory for this lab, located at \texttt{\textasciitilde/lab\thelab}.
Within that directory, there is a file called \texttt{sourceMe} which is used to start the virtual environment.
To activate the virtual environment, run the \texttt{source} command as shown in listing~\ref{lst:init-example}.
You should see a \texttt{(.venv)} appear in your prompt, confirming the environment is activated.
\point{You will need to activate the virtual environment \textbf{in each terminal} that runs code belonging to this lab.}

\warn{The \texttt{ece361} library used in this lab is different than the one from lab 1. Your lab 1 code will not work in this new virtual environment.}

In your lab \thelab~working directory, you should have the following files:
\begin{itemize}
    \item \texttt{lab2-createNet}, \texttt{lab2-enterHost}, and \texttt{lab2-adjustLoss},
        \begin{itemize}
            \item Various scripts for setting up and configuring the lab's virtual network
        \end{itemize}

    \item \texttt{example} directory, with \texttt{client\_improved.py}, \texttt{client\_simple.py}, and \texttt{server.py} within
        \begin{itemize}
            \item Sample code showing how to use the \texttt{ece361} library code (documented in Appendix~\ref{sec:appendix})
        \end{itemize}

    \item \texttt{sender.py} and \texttt{receiver.py}
        \begin{itemize}
            \item The primary files you will run during this lab
        \end{itemize}

    \item \texttt{senderbase.py}, \texttt{stopwaitsender.py}, and \texttt{slidingwindowsender.py}
        \begin{itemize}
            \item Base sender class and two derived classes (which you will have to finish implementing)
        \end{itemize}

    \item \texttt{config.json}
        \begin{itemize}
            \item Configuration file that will be read by the sender and receiver
        \end{itemize}

    \item \texttt{binary\_file\_large} and \texttt{text\_file\_small.txt}
        \begin{itemize}
            \item Test files you will use during this lab
        \end{itemize}
\end{itemize}

\point{If you discover a bug in any of the files provided, please report it on Piazza.}

%-------------------------------------------------------------------------------------------------
\section{Provided Scripts}
\label{sec:provided-scripts}
%-------------------------------------------------------------------------------------------------
This section will provide an overview of the scripts provided to you as part of this lab, and show examples of their usage.

%-------------------------------------------------------------------------------------------------
\subsection{Virtual Network}
%-------------------------------------------------------------------------------------------------
In this lab you will create a virtual network consisting of two hosts connected via a single switch\footnote{A network switch is a type of packet forwarding device}, all fully emulated within your virtual machine (VM).
A script named \texttt{lab2-createNet} has been provided to you within the lab working directory, which will create the virtual network with the topology described.
When you run the script, you should see something similar to listing~\ref{lst:create-virtual-net}.

\begin{lstlisting}[style=ece361shell, caption={Creating the virtual network.}, label={lst:create-virtual-net}]
ubuntu@ece361:~/lab2$ ./lab2-createNet
Creating new virtual network (2 hosts, 1 switch)...
Configuring host IP addresses...
Done.


Created two hosts with (ID: IP):
        h1: 192.168.1.1
        h2: 192.168.1.2

\end{lstlisting}

The virtual network's two hosts, as seen in listing~\ref{lst:create-virtual-net}, has been assigned IPs \texttt{192.168.1.1} and \texttt{192.168.1.2}.

%-------------------------------------------------------------------------------------------------
\subsection{Entering a Virtual Host}
%-------------------------------------------------------------------------------------------------
To run commands from within one of the virtual hosts, you will need to first "enter" it using the \texttt{lab2-enterHost} script provided to you.
See listing~\ref{lst:become-host} for an example of how to run the script.

\begin{lstlisting}[style=ece361shell, caption={Entering into one of the virtual hosts.}, label={lst:become-host}]
ubuntu@"ece361":~/lab2$ ./lab2-enterHost h1
ubuntu@"ece361-h1":~/lab2$
ubuntu@ece361-h1:~/lab2$ ifconfig
h1-eth0   Link encap:Ethernet  HWaddr 1a:8f:9d:d2:0c:99
          inet addr:192.168.1.1  Bcast:192.168.1.255  Mask:255.255.255.0
...
\end{lstlisting}

In the example shown in listing~\ref{lst:become-host}, note the changed command-line prompt, which indicates that the terminal is now within virtual host h1.
Running \texttt{ifconfig} as shown, note the interface has an IP of \texttt{192.168.1.1}, as expected for this particular host.

%Network namespaces virtualize the network stack. Each network namespace contains its own interfaces, routing tables and iptables rules. The script for setting up 2 network namespaces and a communication channel between them is provided to you. Run the following command:
%You might have guessed it, 2 namespaces, h1 and h2 are created and we opened a bash shell within each namespace. Now, we can find out about each namespace using the utility commands introduced in lab 1. For example, in terminal 1, run:
%The first entry is the loopback interface which is created by default when the namespace gets created. The second entry veth1 is the most important. It is created for communication between h1 and h2. As you can see, in the h1 interface the ip address associated with veth1 is 192.168.1.1. Similarly, the ip address for h2 is 192.168.1.2.

To test the communication between virtual hosts h1 and h2, first enter h1 on an open terminal, and ping\footnote{"ping" is a command-line utility to test connectivity between hosts. It is also often used as a verb.} \texttt{192.168.1.2}.
If the virtual network is functioning correctly, the ping should work, as seen in listing~\ref{lst:ping-h2}.

\begin{lstlisting}[style=ece361shell, caption={Pinging h2 from within h1.}, label={lst:ping-h2}]
ubuntu@ece361-h1:~/lab2$ ping -c 4 192.168.1.2
PING 192.168.1.2 (192.168.1.2) 56(84) bytes of data.
64 bytes from 192.168.1.2: icmp_seq=1 ttl=64 time=0.056 ms
64 bytes from 192.168.1.2: icmp_seq=2 ttl=64 time=0.060 ms
64 bytes from 192.168.1.2: icmp_seq=3 ttl=64 time=0.046 ms
64 bytes from 192.168.1.2: icmp_seq=4 ttl=64 time=0.076 ms

--- 192.168.1.2 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 2997ms
rtt min/avg/max/mdev = 0.046/0.059/0.076/0.013 ms
\end{lstlisting}

\hint{If you wish to exit the virtual host at any point, simply type \texttt{exit} on the command-line.}

%-------------------------------------------------------------------------------------------------
\subsection{Emulating Frame Loss}
%-------------------------------------------------------------------------------------------------
To see the effects of ARQ, we need an unreliable channel between the two virtual hosts.
To emulate frame loss, we have provided a script called \texttt{lab2-adjustLoss} which allows you to control the loss rate of frames entering a particular host.
For example, listing~\ref{lst:adjust-loss} shows how to set a frame loss rate of 10\% for frames entering h1.

\warn{The \texttt{lab2-adjustLoss} script will \textbf{not} work if the terminal is within a virtual host, so double-check your prompt.}

\begin{lstlisting}[style=ece361shell, caption={Emulating 10\% frame loss for frames entering h1.}, label={lst:adjust-loss}]
ubuntu@ece361:~/lab2$ ./lab2-adjustLoss h1 10%
\end{lstlisting}

To test the effect of the loss rate, we will use a tool called \texttt{iperf}.
With two terminals, enter h1 in one terminal, and enter h2 in the other.
In terminal h1, run an \texttt{iperf} server (the terminal will pause, waiting for a client to connect and send it data), as shown in listing~\ref{lst:iperf-server}.

\begin{lstlisting}[style=ece361shell, caption={Running an \texttt{iperf} server in h1.}, label={lst:iperf-server}]
ubuntu@ece361:~/lab2$ ./lab2-enterHost h1
ubuntu@ece361-h1:~/lab2$ iperf -s -u
------------------------------------------------------------
Server listening on UDP port 5001
Receiving 1470 byte datagrams
UDP buffer size:  208 KByte (default)
------------------------------------------------------------

\end{lstlisting}

In a second terminal, we enter h2 and run \texttt{iperf} client to send traffic to h1 at a rate of 100 Mbps.
Listing~\ref{lst:iperf-client} show the client in action with the end result highlighted, verifying the frame loss is being properly emulated.

\begin{lstlisting}[style=ece361shell, caption={Running an \texttt{iperf} client in h2.}, label={lst:iperf-client}]
ubuntu@ece361:~/lab2$ ./lab2-enterHost 2
ubuntu@ece361-h2:~/lab2$ iperf -c 192.168.1.1 -u -b 100M
------------------------------------------------------------
Client connecting to 192.168.1.1, UDP port 5001
Sending 1470 byte datagrams
UDP buffer size:  208 KByte (default)
------------------------------------------------------------
[  3] local 192.168.1.2 port 46722 connected with 192.168.1.1 port 5001
[ ID] Interval       Transfer     Bandwidth
[  3]  0.0-10.0 sec   120 MBytes   101 Mbits/sec
[  3] Sent 85471 datagrams
[  3] Server Report:
[  3]  0.0-10.0 sec   108 MBytes  90.5 Mbits/sec   0.001 ms (@"\btHL 8539/85470 (10\%)"@)
[  3]  0.0-10.0 sec  6 datagrams received out-of-order
\end{lstlisting}

After this test, you may kill the \texttt{iperf} server in the h1 terminal by pressing \texttt{Ctrl+C}.

\point{For the remainder of this lab, we assume you have opened at least 3 terminals: one outside of the virtual hosts, one within host h1, and the other within host h2.}

%\begin{lstlisting}[style=ece361shell, caption={terminal outside of hosts}]
%ubuntu@ece361:~/lab2$
%\end{lstlisting}
%
%\begin{lstlisting}[style=ece361shell, caption={h1 terminal}]
%ubuntu@ece361-h1:~/lab2$
%\end{lstlisting}
%
%\begin{lstlisting}[style=ece361shell, caption={h2 terminal}]
%ubuntu@ece361-h2:~/lab2$
%\end{lstlisting}

%-------------------------------------------------------------------------------------------------
\section{A Simple Client-Server Example}
\label{sec:example}
%-------------------------------------------------------------------------------------------------
\work{Before starting this section, it is highly recommended that you go through Appendix~\ref{sec:appendix} to get familiar with the lab 2 library we provided to you.}

We have provided you with a simplified example to illustrate some of the concepts of this lab.
In all 3 terminals, browse into the \texttt{example} directory. We need some frames to be dropped for this example to be meaningful. Add a drop rate of 20\% to both hosts.
\begin{lstlisting}[style=ece361shell, caption={}]
ubuntu@ece361:~/lab2/example$ ./lab2-adjustLoss h1 20%
ubuntu@ece361:~/lab2/example$ ./lab2-adjustLoss h2 20%
\end{lstlisting}

Now from the h1 terminal, run: \texttt{python3 server.py}.
This starts a simple server on host h1. This server is a simple receiver that will reply to each frame it receives with an ACK contianing the next sequence number it expects.
%\begin{lstlisting}[style=ece361shell, caption={}]
%ubuntu@ece361-h1:~/lab2/example$ python3 server.py
%\end{lstlisting}

Now from the h2 terminal, run: \texttt{python3 client\_simple.py}
This simple client, which uses the stop-and-wait ARQ protocol, will transmit 10 frames and report which ones got ACKed and which ones timed out.
The timeout is hardcoded to 1 second. When the client program finishes, it prints out the result like that seen in listing~\ref{lst:client-stats}.
%\begin{lstlisting}[style=ece361shell, caption={}]
%ubuntu@ece361-h2:~/lab2/example$ python3 client_simple.py
%\end{lstlisting}
\begin{lstlisting}[style=ece361shell, caption={}, label={lst:client-stats}]
Frames delivered: 8
Frames timedout: 2
Total transmission time: 0:00:02.025744
\end{lstlisting}

As you can see, in this implementation, the total transmission time depends on the number of frames that time out.
The more frames that time out, the longer it takes for the client to complete the task.
By using stop-and-wait ARQ, the client must wait for the acknowledgement of each frame before sending the next one.
Thus, this implementation is quite inefficient.

To see an improved client implementation, run \texttt{python3 client\_improved.py} in h2. You may keep the server in h1 running.
%\begin{lstlisting}[style=ece361shell, caption={}]
%ubuntu@ece361-h2:~/lab2/example$ python3 client_improved.py
%\end{lstlisting}

The output should look something like this:
\begin{lstlisting}[style=ece361shell, caption={}]
ubuntu@ece361-h2:~/lab2/example$ python3 client_improved.py
b'This is message # 5' DELIVERED. ACK: 6 rtt: 0:00:00.002422
b'This is message # 4' DELIVERED. ACK: 5 rtt: 0:00:00.003443
b'This is message # 2' DELIVERED. ACK: 3 rtt: 0:00:00.004136
b'This is message # 0' DELIVERED. ACK: 1 rtt: 0:00:00.004697
b'This is message # 8' DELIVERED. ACK: 9 rtt: 0:00:00.002196
b'This is message # 9' DELIVERED. ACK: 10 rtt: 0:00:00.002368
b'This is message # 3' TIMED OUT.
b'This is message # 1' TIMED OUT.
b'This is message # 6' TIMED OUT.
b'This is message # 7' TIMED OUT.
Frames delivered: 6
Frames timedout: 4
Total transmission time: 0:00:01.004118
\end{lstlisting}

Notice that the acknowledgements no longer come in order.
More importantly, the total transmission time is at most 1 timeout period regardless of the number of frames that time out.
%This is an improvement over \texttt{client\_simple.py}.
To achieve this performance, \texttt{client\_improved.py} no longer uses stop-and-wait.
Instead, it simultaneously transmits all the frames and then waits for the acknowledgements.
The same idea can be applied to improving the stop-and-wait ARQ: transmit more frames in parallel (and wait for multiple acknowledgements) to keep the channel busy.

You should have a high-level understanding of these client implementations before proceeding to the next section.
Open the files \texttt{client\_simple.py} and \texttt{client\_improved.py} and try to understand the code.
When in doubt, refer to Appendix~\ref{sec:appendix} for more information.

%-------------------------------------------------------------------------------------------------
\section{Stop-and-Wait ARQ}
\label{sec:stop-and-wait}
%-------------------------------------------------------------------------------------------------
In this section you will explore the stop-and-wait ARQ, first in an errorless channel, then in a error-prone channel.
You will see the effects of frame loss in the forward direction (sender to receiver), as as well as the reverse direction (receiver to sender, in the case of ACKs).
Then you will see how to handle these errors.

%-------------------------------------------------------------------------------------------------
\subsection{Stop-and-Wait (Errorless Channel)}
%-------------------------------------------------------------------------------------------------
We begin by introducing stop-and-wait when there iss no risk of frame loss (similar to lab 1).
Open the configuration file, \texttt{config.json}, and make sure it matches the following (which should be the default):
\begin{lstlisting}[style=ece361-shell-base, caption={Configuration For Small File}]
ubuntu@ece361:~/lab2$ cat config.json
{
    "sender_address": "192.168.1.2",
    "receiver_address": "192.168.1.1",
    "receiver_port": 6789,
    "arq_protocol": "stopandwait",
    "timeout": null,
    "frame_size": 1,
    "window_size": 2,
    "maxseqnum": 0
}
\end{lstlisting}

First, let's ensure we have an errorless channel. Using the \texttt{lab2-adjustLoss} script, set the frame loss rate in both directions to 0\%.
%\begin{lstlisting}[style=ece361shell, caption={Setting frame loss to 0\% in both directions.}]
%ubuntu@ece361:~/lab2$ ./lab2-adjustLoss h1 0%
%ubuntu@ece361:~/lab2$ ./lab2-adjustLoss h2 0%
%\end{lstlisting}

From the h1 terminal, run:
\begin{lstlisting}[style=ece361-shell-base, caption={}]
ubuntu@ece361-h1:~/lab2$ python3 receiver.py received.txt
\end{lstlisting}

From the h2 terminal, run:
\begin{lstlisting}[style=ece361-shell-base, caption={}]
ubuntu@ece361-h2:~/lab2$ python3 sender.py text_file_small.txt
\end{lstlisting}

When the sender is finished, verify that the file got successfully:
\begin{lstlisting}[style=ece361-shell-base, caption={}]
ubuntu@ece361-h2:~/lab2$ cat received.txt
I only have a few bytes.
\end{lstlisting}

%Since the receiver is just a server that always listens to incoming frames, it does not know when the transmission ends.
%Therefore, you need to manually \texttt{Ctrl-C} the receiver when the sender finishes. This applies to the rest of the sections in the lab.
\warn{Unlike the simple ACK server in section~\ref{sec:example}, you cannot keep the receiver running between experiments. If you want to start a new transmission, you have to stop the receiver using \texttt{Ctrl-C}. This ensures the destination file is closed before starting the next transmission, otherwise it will simply append to the file and won't yield the desired result.}

%-------------------------------------------------------------------------------------------------
\subsection {The \texttt{-{}-debug} Option}
%-------------------------------------------------------------------------------------------------
We have provided you with a debugging feature that prints out the progress on the sender and receiver frame by frame.
This is very useful for either debugging or just to understand how the protocol works.

Try the previous stop-and-wait example with the \texttt{-{}-debug} flag set and try to understand the debug messages.
From the h1 terminal, run \texttt{python3 receiver.py -{}-debug received.txt}.
Then from the h2 terminal, run \texttt{python3 sender.py -{}-debug text\_file\_small.txt}
%\begin{lstlisting}[style=ece361-shell-base, caption={}]
%ubuntu@ece361-h1:~/lab2$ python3 receiver.py --debug received.txt
%\end{lstlisting}
%
%From the h2 terminal:
%\begin{lstlisting}[style=ece361-shell-base, caption={}]
%ubuntu@ece361-h2:~/lab2$ python3 sender.py --debug text_file_small.txt
%\end{lstlisting}

%Try understanding the debug message. It shouldn't be too hard since this is just a simple stop-and-wait and you implemented the same algorithm in lab 1. However, later on when the algorithm gets more complicated this will become more useful.

%-------------------------------------------------------------------------------------------------
\subsection{Round Trip Time (RTT)}
%-------------------------------------------------------------------------------------------------
Round trip time, or RTT, is the time it takes for the sender to send a frame and receive an ACK back for that particular frame.
You will need to update the sender code to calculate the RTT.

Let's start by trying to send a larger file. We need to increase the frame size so the transmission doesn't take forever.
Modify the \texttt{confg.json} file and set the frame size to 1024 (or 1K bytes).
%Let's change the frame size to 1024 (or 1K bytes):
%\begin{lstlisting}[style=ece361-shell-base, caption={Configuration For Large File}]
%{
%    "sender_address": "192.168.1.2",
%    "receiver_address": "192.168.1.1",
%    "receiver_port": 6789,
%    "arq_protocol": "stopandwait",
%    "timeout": null,
%    "frame_size": 1024,
%    "window_size": 2,
%    "maxseqnum": 0
%}
%\end{lstlisting}

\warn{Do not use the \texttt{-{}-debug} option when sending large files! The debug messages will flood your screen.}

From the h1 terminal, run:
\begin{lstlisting}[style=ece361-shell-base, caption={}]
ubuntu@ece361-h1:~/lab2$ python3 receiver.py received
\end{lstlisting}

From the h2 terminal, run:
\begin{lstlisting}[style=ece361-shell-base, caption={}]
ubuntu@ece361-h2:~/lab2$ python3 sender.py binary_file_large
\end{lstlisting}

Verify that the file was successfully transmitted using \texttt{diff}.
Note that no output from the \texttt{diff} utility indicates that both files are byte-by-byte identical.
\begin{lstlisting}[style=ece361-shell-base, caption={}]
ubuntu@ece361-h1:~/lab2$ diff binary_file_large received
\end{lstlisting}

When the transmission ends, the sender will print some statistics (e.g. see listing~\ref{lst:sender-stats}.
\begin{lstlisting}[style=ece361-shell-base, caption={Example of sender statistics}, label={lst:sender-stats}]
ARQ protocol: stopandwait
Frames sent: 9106
Frames delivered: 9106
Transmission time: 0:00:23.292909
Average RTT: 0:00:00
Maximum RTT: 0:00:00
\end{lstlisting}

We have implemented the \texttt{Frames sent}, \texttt{Frames delivered} and \texttt{Transmission time} statistics for you.
We have left the RTT statistics for you to implement.

\work{Complete the \texttt{\_update\_rtt} class method in \texttt{stopwaitsender.py} so that it updates the \texttt{rtt\_max} and \texttt{rtt\_total} member variables.}
%You need to first calculated a new RTT sample based on \texttt{t\_send} and \texttt{t\_ack} and then update the \texttt{rtt\_max} and \texttt{rtt\_total} member variables.
%The rest of the calculations (e.g. average) has already been implemented for you.
After you are done, re-run the previous \texttt{binary\_file\_large} experiment and make sure you get the RTT statistics printed out.


%-------------------------------------------------------------------------------------------------
\subsection{Handling Frame Drop}
%-------------------------------------------------------------------------------------------------
We will now see the effects of frame drops. After you get the basic stop-and-wait working, enable frame drops for packets going into h1.
Keep the reverse direction (frames from h1 going to h2) errorless for now.
For example, set the frame drop rate to 5\%:
\begin{lstlisting}[style=ece361-shell-base, caption={}]
ubuntu@ece361:~/lab2$ ./lab2-adjustLoss h1 5%
\end{lstlisting}

Modify the configuration file and change the frame size back to 1 for now.
%\begin{lstlisting}[style=ece361-shell-base, caption={Configuration For Large File}]
%{
%    "sender_address": "192.168.1.2",
%    "receiver_address": "192.168.1.1",
%    "receiver_port": 6789,
%    "arq_protocol": "stopandwait",
%    "timeout": null,
%    "frame_size": 1,
%    "window_size": 2,
%    "maxseqnum": 0
%}
%\end{lstlisting}
Re-run the \texttt{text\_file\_small.txt} with the \texttt{-{}-debug} option. What is the result and why?

%-------------------------------------------------------------------------------------------------
\subsubsection {Choosing a Timeout}
%-------------------------------------------------------------------------------------------------
When a frame is lost, the sender would be waiting forever for an the acknowledgement forever.
To fix this, the sender needs an appropriate timeout for each frame, such that when the timeout occurs, the sender retransmits the previous frame.
Based on your RTT calculation in the previous section, change the \texttt{"timeout"} field of the configuration file from \texttt{null} to an appropriate value (\textbf{Note:} The unit is in seconds, and floating point numbers are accepted).

\think{Should the timeout be based on the average or maximum RTT? Why?}

Re-run the \texttt{text\_file\_small.txt} experiment and test if the transmission is successful.
After you get the small file working, change the frame size to 1024 and try transmitting \texttt{binary\_file\_large}.

\think{Can you figure a mathematical relationship between the expected frames sent, frames deliverd and the frame drop rate? Does the experimental result agree with your formula?}

%-------------------------------------------------------------------------------------------------
\subsection {Handling Lost ACKs}
%-------------------------------------------------------------------------------------------------
Now we will see the effect of frame loss for ACKs. Set a frame loss rate of 5\% for frames entering into h2.
\begin{lstlisting}[style=ece361-shell-base, caption={}]
ubuntu@ece361:~/lab2$ ./lab2-adjustLoss h2 5%
\end{lstlisting}

Change the frame size configuration back to 1 and re-run the \texttt{text\_file\_small.txt} experiment.
Examine the resulting file created by the receiver. You should see something similar to listing~\ref{lst:dup-frames}.
The actual result varies from run to run, but the key here is duplicated frames.
If you don't see duplicated frames then increase the frame drop rate (e.g. 10\%) and try the experiment again.
%\begin{lstlisting}[style=ece361-shell-base, caption={Configuration For Large File}]
%{
%    "sender_address": "192.168.1.2",
%    "receiver_address": "192.168.1.1",
%    "receiver_port": 6789,
%    "arq_protocol": "stopandwait",
%    "timeout": <your choice>,
%    "frame_size": 1,
%    "window_size": 2,
%    "maxseqnum": 0
%}
%\end{lstlisting}

\begin{lstlisting}[style=ece361-shell-base, caption={Example of duplicate frames being received.}, label={lst:dup-frames}]
ubuntu@ece361-h1:~/lab2$ cat received.txt
I only havee a few bytess.
\end{lstlisting}

\think{Pause here and think if you can figure out why this happens.}

When an ACK frame is lost, the sender will eventually time out and re-send a frame.
Without the use of sequence numbers to distinguish subsequent frames, the receiver cannot tell if a frame is a duplicate.

The implementation we have provided already supports sequence numbers, you just need to enable it in the configuration file.
Set the \texttt{"maxseqnum"} field of the configuration file to any positive integer (e.g. 64) and re-run the \texttt{text\_file\_small.txt} experiment.
You should see that the file gets successfully transmitted without duplicated frames.
%\begin{lstlisting}[style=ece361-shell-base, caption={}]
%{
%    "sender_address": "192.168.1.2",
%    "receiver_address": "192.168.1.1",
%    "receiver_port": 6789,
%    "arq_protocol": "stopandwait",
%    "timeout": <your choice>,
%    "frame_size": 1,
%    "window_size": 2,
%    "maxseqnum": 64
%}
%\end{lstlisting}

Finally, let's test the fully implemented stop-and-wait ARQ protocol on \texttt{binary\_file\_large}. Set the frame size back to 1024 and re-run the experiment.
You might need to wait for a while for the transmission to finish. When it does, verify that the file gets successfully transmitted using \texttt{diff}.

%\begin{lstlisting}[style=ece361-shell-base, caption={Configuration For Large File}]
%{
%    "sender_address": "192.168.1.2",
%    "receiver_address": "192.168.1.1",
%    "receiver_port": 6789,
%    "arq_protocol": "stopandwait",
%    "timeout": <your choice>,
%    "frame_size": 1024,
%    "window_size": 2,
%    "maxseqnum": 64
%}
%\end{lstlisting}

%From the h1 terminal, run: \texttt{python3 receiver.py received}.
%\begin{lstlisting}[style=ece361-shell-base, caption={}]
%ubuntu@ece361-h1:~/lab2$ python3 receiver.py received
%\end{lstlisting}

%From the h2 terminal, run: \texttt{python3 sender.py binary\_file\_large}.
%\begin{lstlisting}[style=ece361-shell-base, caption={}]
%ubuntu@ece361-h2:~/lab2$ python3 sender.py binary_file_large
%\end{lstlisting}

%You might need to wait for a while for the transmission to finish. When it does, verify that the file gets successfully transmitted using \texttt{diff}.
%\begin{lstlisting}[style=ece361-shell-base, caption={}]
%ubuntu@ece361-h1:~/lab2$ diff binary_file_large received
%\end{lstlisting}

If the previous experiment succeeds, congratulations! You have a fully working stop-and-wait ARQ.
Now open the \texttt{stopwaitsender.py} file and have a look at the \texttt{\_arqsend} function.
You should understand the code at a high level before proceeding to the next section.
You only need to understand what the API calls in that function are doing (you do not need to understand the details of how the APIs work under-the-hood).
Also, you only need to look at that one single function, you do not need to read other parts of the code.
However, if you are interested, you can read the entire code-base since we made all the source code available to you.

%-------------------------------------------------------------------------------------------------
\section{Sliding Window ARQ (Send Many, Receive One)}
\label{sec:sliding}
%-------------------------------------------------------------------------------------------------
In this section, you will complete the implementation of a sender that uses the Send Many, Receive One ARQ protocol.
Section~\ref{subsec:config-file-slidingwindow} shows how to configure the sender to use the Send Many, Receive One protocol.
Section~\ref{sec:protocol} provides a technical overview of the protocol, and section~\ref{subsec:implement-slidingwindow} describes your task.

%-------------------------------------------------------------------------------------------------
\subsection{Configuring the Sender to Use Sliding Window ARQ}
\label{subsec:config-file-slidingwindow}
%-------------------------------------------------------------------------------------------------
Update the configuration file.
Change the \texttt{"arq\_protocol"} field of the configuration file from \texttt{"stopandwait"} to \texttt{"slidingwindow"}.
Make sure \texttt{"window\_size"} is an integer greater than 1.
Make sure \texttt{"maxseqnum"} is at least \texttt{"window\_size"}.
Keep other parameters (e.g. timeout) the same as in the stop-and-wait section.
\begin{lstlisting}[style=ece361-shell-base, caption={Sliding Window Configuration}]
{
    "sender_address": "192.168.1.2",
    "receiver_address": "192.168.1.1",
    "receiver_port": 6789,
    "arq_protocol": "slidingwindow",
    "timeout": <your choice>,
    "frame_size": 1,
    "window_size": 2,
    "maxseqnum": 64
}
\end{lstlisting}

\think{If you set the window-size to be 1, what does the Sliding Window ARQ become?\\
Why must the \texttt{"maxseqnum"} be at least \texttt{"window\_size"}?}
%\think{Why must the \texttt{"maxseqnum"} be at least \texttt{"window\_size"}?}

Try running the \texttt{text\_file\_small.txt} experiment with \texttt{-{}-debug} the same way as before.
From the h1 terminal, run: \texttt{python3 receiver.py --debug received.txt}.
%\begin{lstlisting}[style=ece361-shell-base, caption={}]
%ubuntu@ece361-h1:~/lab2$ python3 receiver.py --debug received.txt
%\end{lstlisting}
From the h2 terminal, run: \texttt{python3 sender.py --debug text\_file\_small.txt}.
%\begin{lstlisting}[style=ece361-shell-base, caption={}]
%ubuntu@ece361-h2:~/lab2$ python3 sender.py --debug text_file_small.txt
%\end{lstlisting}

As you can see, the programs will hang without any debug outputs, which means no frame is being sent or received.
This shouldn't surprise you since sliding window ARQ has not been implemented yet!
Open the \texttt{slidingwindowsender.py} file and find the \texttt{\_arqsend} method.

\work{Your task is to complete the \texttt{\_arqsend} method. We have started the implementation for you by creating a send queue.}
%We have started the implementation for you by creating a send queue and your task is to complete the method.
Apart from this method, the rest of the sender functions are already implemented for you.

\hint{We have given you some high level guidelines on what to do as well in the comments. Before starting, make sure you have read section~\ref{sec:protocol}, which explains our implementation (it may differ in minor details from what you have learned).}
%Briefly go through the comments to have an idea of what needs to be done, but before you start coding, you must read the next section for a detailed description of our implementation of the sliding window protocol, which might differ in a few minor details from what you have learned.

%-------------------------------------------------------------------------------------------------
\subsection{Protocol Description}
\label{sec:protocol}
%-------------------------------------------------------------------------------------------------
As you can see from Figure~\ref{sw}, stop-and-wait ARQ is inefficient because the channel is idle during the period where the sender waits for acknowledgement from the receiver.
It would be much more efficient if the channel could be kept busy during this waiting period.
This is where sliding window ARQ comes in. Figure~\ref{sliding} illustrates how sliding window works on a perfect, errorless channel.
\figvs{0.35}{sw}{trim=0cm 0cm 0cm 0cm,clip}{Stop-and-Wait ARQ Timing Diagram}
\figvs{0.35}{sliding}{trim=0cm 0cm 0cm 0cm,clip}{Sliding Window ARQ Timing Diagram}

A sliding window can be implemented on both the sender and the receiver side, but for this lab, we only consider sliding window on the sender side.
The receiver still accepts one frame at a time, similar to a stop-and-wait receiver.
Thus, our protocol behave like "Send Many, Receive One".

Note that one needs to make sure that the sliding window is implemented correctly.
A typical incorrect implementation is illustrated in Figure~\ref{sliding_incorrect} where frames 1, 2 and 3 should not be resent.
\figvs{0.35}{sliding_incorrect}{trim=0cm 0cm 0cm 0cm,clip}{Sliding Window ARQ Incorrect Implementation}


%-------------------------------------------------------------------------------------------------
\subsubsection{Error Control}
%-------------------------------------------------------------------------------------------------
The most basic error control mechanisims in sliding window ARQ are acknowledgement and timeout, much like stop-and-wait.
Upon receiving a frame with the expected sequence number, the receiver sends back an ACK with the next sequence number.
The acknowledgements are independently sent to every frame.
The sender maintains a timer for each frame, which starts right after the frame is sent.
If, after some timeout period, the frame does not receive its corresponding ACK, the frame is retransmitted.
As illustrated in Figure~\ref{sliding_error}, frame 0 is retransmitted after some timeout period.
\figvs{0.35}{sliding_error}{trim=0cm 0cm 0cm 0cm,clip}{Sliding Window ARQ Error Control}

Consider the case in Figure~\ref{ack_multi}. Frames 0, 1, 2, and 3 all transmitted successfully but the ACKs are all lost.
From the sender's point of view there is no difference to the case where the frames are lost, so it retransmits frame 0.
When the receiver receives the duplicate frame 0, it should send acknowledgements for frames 0, 1, 2 and 3 since those frames have all been received.
However, a more bandwidth efficient way is to use what is called a "culmulative ACK", in which the receiver only sends an ACK for frame 3 (ACK 4), implying that frames 0 through 3 have all been received.
When the sender receives this ACK, it immediately sends frame 4, as illustrated in the figure.
Note that if the sender does not know about culmulative ACKs it won't be able to correctly communicate with the receiver.
\figvs{0.4}{ack_multi}{trim=0cm 0cm 0cm 0cm,clip}{Culmulative ACK}

In the same way, when an ACK for a certain frame is received, it is implied that all frames earlier than that frame were also correctly received, even if their ACKs never arrived. This case is illustrated in Figure~\ref{ack_multi_handle}.
Upon receiving the ACK, the sender can immediately start transmitting the next frame.
\figvs{0.4}{ack_multi_handle}{trim=0cm 0cm 0cm 0cm,clip}{Culmulative ACK Handling}

There is an implementation detail on what the sender should do upon receiving a culmulative ACK half way through transmitting the send window.
The best implementation is shown in Figure~\ref{ack_multi_handle}, where the sender aborts the current send window and immediately start sending the frame with the correct sequence number.
However, this is sometimes challenging to implement.
Therefore, in this lab, you will do a simpler but less efficient implementation as illustrated in Figure~\ref{ack_multi_handle2}, where the sender is allowed to finish the current send window and then start sending the correct frame.
This is less efficient due to extra duplicated frames being sent, but easier to implement.
\figvs{0.4}{ack_multi_handle2}{trim=0cm 0cm 0cm 0cm,clip}{Culmulative ACK Handling (Simpler Implementation)}

Finally, there is one last case we need to cover, which is frames that arrive out of order.
As illustrated in Figure~\ref{nack}, if frames 0 is lost, frames 1, 2, 3 will be considered to be out of order by the receiver.
Thus, it rejects the frame and sends a NACK with the sequence number of the frame it expects (in this case, frame 0).
In our implementation, NACKs are always sent for out of order frames.
\figvs{0.35}{nack}{trim=0cm 0cm 0cm 0cm,clip}{Out of Order Frames and NACKs}

%Note that the NACK here in this lab might not be what you think it is. It is just called NACK to distinguish it from an ACK.
Note that in this lab, implementation-wise, there is no difference between a NACK and a resend of the ACK for the last received frame.
%So to some extent NACKs in our context is no different than cumulative ACKs except that it is sending ACKs for frames in the past instead of frames in the future.
You may have learned that the term "NACK" is also used in the context of indicating frame corruption, but you don't have to worry about that in this lab.
You can assume that if a frame arrives at the receiver, it always arrives without error.

\think{If we do not send any NACKs, does the sliding window ARQ still work? If the answer is yes, what mechanism will it rely on for the sender to know to re-transmit the correct frame, and why are NACKs useful then?}

%-------------------------------------------------------------------------------------------------
\subsection{Implement the Sliding Window ARQ}
\label{subsec:implement-slidingwindow}
%-------------------------------------------------------------------------------------------------
Based on what you've learned so far, implement the \texttt{\_arqsend} function in \texttt{slidingwindowsender.py}.
During the debugging stage, it is recommended to test transmission using \texttt{text\_file\_small.txt}, with frame size of 1, and \texttt{-{}-debug} on.
However, the \texttt{DEBUG} messages on the sender side needs to be implemented by you.
After testing your code on the small text file, test sending the \texttt{binary\_file\_large} file using a frame size of 1024 and 5\% channel loss in both directions.
After the transmission is done, use the \texttt{diff} command to make sure that the file is transmitted successfully.

\hint{If you get stuck, take a look at \texttt{client\_improved.py} in the example directory and understand it in detail. A lot of the ideas used in that progam are directly applicable to implementing sliding window ARQ.}
%\hint{You can check whether your code follows the protocol correctly by inserting \texttt{print} statements in your code and transmit \texttt{text\_file\_small.txt} with a frame size of 1 while running the receiver with the \texttt{-{}-debug} option.}

%-------------------------------------------------------------------------------------------------
\subsection{Getting the Optimal Window Size}
%-------------------------------------------------------------------------------------------------
Start with the following configuration:
\begin{lstlisting}[style=ece361-shell-base, caption={Sliding Window Configuration}]
{
    "sender_address": "192.168.1.2",
    "receiver_address": "192.168.1.1",
    "receiver_port": 6789,
    "arq_protocol": "slidingwindow",
    "timeout": <your choice>,
    "frame_size": 1024,
    "window_size": 2,
    "maxseqnum": 64
}
\end{lstlisting}

Transmit the \texttt{binary\_file\_large} file.
Do you see an improved performance compared to Stop-and-Wait?
\think{If you keep increasing the window size, what do you see? Can you explain why?}
\work{Your task is to find an optimal window size. What is your minimum file transmission time?}

You can try to experiment with other binary files types (e.g. images, videos etc.). When the implementation is incorrect, do you see corruption?

%-------------------------------------------------------------------------------------------------
\subsection{Goal}
%-------------------------------------------------------------------------------------------------
Your target is to transmit the \texttt{binary\_file\_large} file under 10 seconds, on a channel with 5\% loss both ways, and a frame size of 1024.
Your sliding window ARQ implementation has to conform to descriptions in Section~\ref{sec:protocol}.
%We will also test with an optimal window size.
We will not only test the time it takes to transmit the file but also test every aspect of the protocol described in Section~\ref{sec:protocol}.
%, so make sure you test your code thoroughly.
Our additional tests for protocol conformation may change parameters such as channel loss, frame size, and window size, so you should test with different parameters, not just the ones given to you in the lab.

\section{Exerciser}
\label{sec:exercise}
%-------------------------------------------------------------------------------------------------
You can use the exerciser to help test the correctness of your implementation. The exerciser will run a set of public test cases against your code. However, note that the tests in the exerciser is not complete and it is your responsibility to test your code to make sure it conforms to Section~\ref{sec:protocol}.
Ensure you have the following files all within the same directory:
\begin{itemize}
    \item \textbf{stopwaitsender.py}: Your completed stop-and-wait sender code from section~\ref{sec:stop-and-wait}.
    \item \textbf{slidingwindowsender.py}: Your completed sliding window sender code from section~\ref{sec:sliding}.
\end{itemize}

In terminal, browse to the directory containing the files and type \texttt{ece361-exercise \thelab}.


%-------------------------------------------------------------------------------------------------
\section{Submission}
\label{sec:submission}
%-------------------------------------------------------------------------------------------------
Once you are confident of your implementation, you can run the submission process (which will invoke the exerciser before submitting).
Only one person in the group needs to submit.

From the same directory as where you ran the exerciser, type \texttt{ece361-submit submit \thelab}.

You can then verify the submission by typing \texttt{ece361-submit list \thelab}.

At some point after the lab's due date, private test cases will be run against your submission to calculate your final mark.

%-------------------------------------------------------------------------------------------------
\newpage
\appendix
\section{Appendix}
\label{sec:appendix}
%-------------------------------------------------------------------------------------------------

%-------------------------------------------------------------------------------------------------
\subsection{The Frame Class}
%-------------------------------------------------------------------------------------------------
In lab 1 you worked with a \texttt{Socket} class. In this lab you will be working with a \texttt{Frame} class which encapsulates the concept of a frame. For this lab we have encapsulated all the functionalities in this class so you do not need to work with sockets directly.

%-------------------------------------------------------------------------------------------------
\subsection{Importing the Library}
%-------------------------------------------------------------------------------------------------
Similar to lab 1 you will need an "import" statement in order to use the library:
\begin{lstlisting}[caption={Import Statement}, language=python]
from ece361.lab2.frame import Frame
\end{lstlisting}

%-------------------------------------------------------------------------------------------------
\subsection{Creation}
%-------------------------------------------------------------------------------------------------
To create a \texttt{Frame} class object, at least 2 parameters are required: \texttt{seqnum} (sequence number) and \texttt{data}, which are self explanatory. The other parameters are optional and illustrated below:
\begin{lstlisting}[caption={Frame Object Instantiation}, language=python]
# Instantiate a new Frame object
new_frame = Frame(
                  # sequence number
                  seqnum,
                  # bytes storing the actual data
                  data,
                  # optional: (ip_address, port) tuple for destination
                  destination,
                  # optional: expected acknowlegement number
                  expected_ack,
                  # optional: timeout for receiving acknowlegement
                  timeout
                  )
\end{lstlisting}

%-------------------------------------------------------------------------------------------------
\subsection{Methods you Need in Order to Complete the Lab}
%-------------------------------------------------------------------------------------------------

%-------------------------------------------------------------------------------------------------
\subsubsection{status()}
%-------------------------------------------------------------------------------------------------
This is one of the key methods for completing this lab. It is for checking the current status of the \texttt{Frame} object. A frame can be in one of the following 4 states: \texttt{notsent}, \texttt{inflight}, \texttt{timedout}, \texttt{ack\_nacked}. To check the current status of the frame, you need to write something similar to the following:
\begin{lstlisting}[caption={Frame status}, language=python]
# Assuming 'frame' is an object instance of the Frame class
if (frame.status() == Frame.Status.notsent):
    # Code here...
\end{lstlisting}

%-------------------------------------------------------------------------------------------------
\subsubsection{send()}
%-------------------------------------------------------------------------------------------------
As the name suggests, this method sends the frame to its destination. It only works if the destination field is not empty when the \texttt{Frame} was created. Note that unlike lab 1, there is no need to pass in the destination address since we assume that a \texttt{Frame}'s destination is determined upon creation (and cannot be modified). If you want to send to a different destination you have to create a new \texttt{Frame} object.

%-------------------------------------------------------------------------------------------------
\subsubsection{wait\_for\_ack\_nack()}
%-------------------------------------------------------------------------------------------------
This method will block until an ACK/NACK for the frame comes back.

%-------------------------------------------------------------------------------------------------
\subsubsection{wait\_for\_multiple\_ack\_nacks(frames\_list)}
%-------------------------------------------------------------------------------------------------
This is an essential function for completing Section \ref{sec:sliding} of the lab.
This is the "non-blocking" counterpart of \texttt{wait\_for\_ack\_nack()}, where a list of frames is passed in and will return if any of the frames in the list receives an ACK/NACK.
If none of the frames in \texttt{frames\_list} receive an ACK/NACK, then this function will block.
This is a static function. In order to use it one needs to proceed its name with \texttt{"Frame"}:
\begin{lstlisting}[caption={Frame status}, language=python]
Frame.wait_for_multiple_ack_nacks(frames_list)
\end{lstlisting}
Note that although this function returns when at least one the frames gets an ACK, it does not tell which frame(s) in the \texttt{frames\_list} is acknowledged.
After this function returns one needs to go through the entire \texttt{frames\_list} again and check the status of each to know which ones got acknowledged.

%-------------------------------------------------------------------------------------------------
\subsection{Other Methods}
%-------------------------------------------------------------------------------------------------
You do not need the following methods for completing this lab. They are used in skeleton and example code, so we include them here for reference purposes.

%-------------------------------------------------------------------------------------------------
\subsubsection{sendtime()}
%-------------------------------------------------------------------------------------------------
Returns a \texttt{datetime} object indicating the time the frame object is sent.
If there are multiple send attempts, it returns the time for the most recent send attempt.
Returns \texttt{None} if the frame was never sent.

%-------------------------------------------------------------------------------------------------
\subsubsection{retrieve\_ack\_nack()}
%-------------------------------------------------------------------------------------------------
Retrieves the ACK/NACK of the frame (if ACK/NACKED), which is a number. This method only works if the frame is in \texttt{ack\_nacked} state.
Since there are no true NACKs in this lab you do not really need this function because ACK is always the next sequence number.
Making sure the frame is in \texttt{ack\_nacked} state is sufficient.

%-------------------------------------------------------------------------------------------------
\subsubsection{acktime()}
%-------------------------------------------------------------------------------------------------
Returns a \texttt{datetime} object indicating the time when the ACK was received.
Returns \texttt{None} if no acknowledgement has been received.

%-------------------------------------------------------------------------------------------------
\subsubsection{pack\_data()}
%-------------------------------------------------------------------------------------------------
Returns the raw "packed" version of the \texttt{Frame} object, which is a sequence of bytes with first 4 bytes being the sequence number, followed by the frame data.
The "packed" version is useful for transmitting the frame over the network.

%-------------------------------------------------------------------------------------------------
\subsubsection{unpack\_data()}
%-------------------------------------------------------------------------------------------------
This is exactly the opposite of \texttt{pack\_data()} where a sequence of bytes is converted to a \texttt{Frame} object, assuming the same format: 4 bytes sequence number followed by data.
Each time this method is called a new \texttt{Frame} object is returned.

\end{document}
