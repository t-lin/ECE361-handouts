\documentclass[11pt]{article}

\usepackage{../style/ece361}

%-------------------------------------------------------------------------------------------------

% Lab parameters
\def\thelab{2}
\def\datedue{Feb. 17, 2020 @ 11:59 PM}

\useCompactTitle{ECE361 Lab \thelab}{Automatic Repeat Request (ARQ) Protocols}

%-------------------------------------------------------------------------------------------------
\begin{document}
% Create title page, and force header and footer onto it
\maketitle \thispagestyle{fancy}
\hfill {\large \textbf{Due \datedue}}
%-------------------------------------------------------------------------------------------------


%-------------------------------------------------------------------------------------------------
\section{Overview}
\label{sec:overview}
%-------------------------------------------------------------------------------------------------
In many applications reliable data transmission over an unreliable service is required. ARQ protocols are for exactly that. In this lab, you will be given 2 virtual hosts and an unreliable channel between them. With that you will first enhance the Stop and Wait protocol implemented in lab 1 to work on an unreliable channel. After that you will implement a better, more efficient sliding window protocol, in particular, the ``send many, receive one'' protocol.

%-------------------------------------------------------------------------------------------------
\subsection{Lab Initialization}
\label{subsec:lab-init}
%-------------------------------------------------------------------------------------------------
This lab includes starter code that uses a custom-built Python 3 library called \texttt{ece361}. A Python virtual environment will be created, that will include the library, where you will do all the work in this lab. Virtual environments must be "activated" before you attempt to run the code inside. We have provided an initialization script for you that will setup this virtual environment, along with the starter code, and the custom library.

\hint{It's highly recommended to update your VM before starting each lab. Open a terminal (in the VM), and type \texttt{ece361-update}}

To run the initialization script for lab \thelab, open a terminal and type \texttt{ece361-lab-init \thelab}. You should see something similar to listing~\ref{lst:init-example}.
\begin{lstlisting}[style=ece361shell, caption={Initializing lab \thelab.}, label={lst:init-example}]
ubuntu@ece361:~$ ece361-lab-init (@"\thelab"@)
Finding available UG EECG host...
Warning: Permanently added 'ug251.eecg.utoronto.ca,128.100.13.251' (ECDSA) to the list of known hosts.
Creating working directory for lab (@"\thelab"@) at (@"\btHL /home/ubuntu/lab\thelab"@)
Creating Python3 virtual environment...
Installing libraries...

...

Done. Now run (@"\btHL source /home/ubuntu/lab\thelab/sourceMe"@) to activate the virtual environment.
\end{lstlisting}

The initialization script creates a working directory for this lab, located at \texttt{\textasciitilde/lab\thelab}.
Within that directory, there is a file called \texttt{sourceMe} which is used to start the virtual environment.
To activate the virtual environment, run the \texttt{source} command as shown in listing~\ref{lst:init-example}.
You should see a \texttt{(.venv)} appear in your prompt, confirming the environment is activated.
\point{You will need to activate the virtual environment \textbf{in each terminal} that runs code belonging to this lab.}

\warn{The \texttt{ece361} library used in this lab is different than the one from lab 1. Your lab 1 code will not work in this new virtual environment.}

In your lab \thelab~working directory, you should have the following files:
\begin{itemize}
    \item \texttt{lab2-createNet}, \texttt{lab2-enterHost}, and \texttt{lab2-adjustLoss},
        \begin{itemize}
            \item Various scripts for setting up and configuring the lab's virtual network
        \end{itemize}

    \item \texttt{example} directory, with \texttt{client\_improved.py}, \texttt{client\_simple.py}, and \texttt{server.py} within
        \begin{itemize}
            \item Sample code showing how to use the \texttt{select()} call in Python
        \end{itemize}

    \item \texttt{sender.py} and \texttt{receiver.py}
        \begin{itemize}
            \item The primary files you will run during this lab
        \end{itemize}

    \item \texttt{senderbase.py}, \texttt{stopwaitsender.py}, and \texttt{slidingwindowsender.py}
        \begin{itemize}
            \item Base sender class and two derived classes (which you will have to finish implementing)
        \end{itemize}

    \item \texttt{config.json}
        \begin{itemize}
            \item Configuration file that will be read by the sender and receiver
        \end{itemize}

    \item \texttt{binary\_file\_large} and \texttt{text\_file\_small.txt}
        \begin{itemize}
            \item Test files you will use during this lab
        \end{itemize}
\end{itemize}

\point{If you discover a bug in any of the files provided, please report it on Piazza.}

%-------------------------------------------------------------------------------------------------
\section{Provided Scripts}
\label{sec:provided-scripts}
%-------------------------------------------------------------------------------------------------
This section will provide an overview of the scripts provided to you as part of this lab, and show examples of their usage.

%-------------------------------------------------------------------------------------------------
\subsection{Virtual Network}
%-------------------------------------------------------------------------------------------------
In this lab you will create a virtual network consisting of two hosts connected via a single switch\footnote{A network switch is a type of packet forwarding device}, all fully emulated within your virtual machine (VM).
A script named \texttt{lab2-createNet} has been provided to you within the lab working directory, which will create the virtual network with the topology described.
When you run the script, you should see something similar to listing~\ref{lst:create-virtual-net}.

\begin{lstlisting}[style=ece361shell, caption={Creating the virtual network.}, label={lst:create-virtual-net}]
ubuntu@ece361:~/lab2$ ./lab2-createNet
Creating new virtual network (2 hosts, 1 switch)...
Configuring host IP addresses...
Done.


Created two hosts with (ID: IP):
        h1: 192.168.1.1
        h2: 192.168.1.2

\end{lstlisting}

The virtual network's two hosts, as seen in listing~\ref{lst:create-virtual-net}, has been assigned IPs \texttt{192.168.1.1} and \texttt{192.168.1.2}.

%-------------------------------------------------------------------------------------------------
\subsection{Entering a Virtual Host}
%-------------------------------------------------------------------------------------------------
To run commands from within one of the virtual hosts, you will need to first "enter" it using the \texttt{lab2-enterHost} script provided to you.
See listing~\ref{lst:become-host} for an example of how to run the script.

\begin{lstlisting}[style=ece361shell, caption={Entering into one of the virtual hosts.}, label={lst:become-host}]
ubuntu@"ece361":~/lab2$ ./lab2-enterHost h1
ubuntu@"ece361-h1":~/lab2$
ubuntu@ece361-h1:~/lab2$ ifconfig
h1-eth0   Link encap:Ethernet  HWaddr 1a:8f:9d:d2:0c:99
          inet addr:192.168.1.1  Bcast:192.168.1.255  Mask:255.255.255.0
...
\end{lstlisting}

In the example shown in listing~\ref{lst:become-host}, note the changed command-line prompt, which indicates that the terminal is now within virtual host h1.
Running \texttt{ifconfig} as shown, note the interface has an IP of \texttt{192.168.1.1}, as expected for this particular host.

%Network namespaces virtualize the network stack. Each network namespace contains its own interfaces, routing tables and iptables rules. The script for setting up 2 network namespaces and a communication channel between them is provided to you. Run the following command:
%You might have guessed it, 2 namespaces, h1 and h2 are created and we opened a bash shell within each namespace. Now, we can find out about each namespace using the utility commands introduced in lab 1. For example, in terminal 1, run:
%The first entry is the loopback interface which is created by default when the namespace gets created. The second entry veth1 is the most important. It is created for communication between h1 and h2. As you can see, in the h1 interface the ip address associated with veth1 is 192.168.1.1. Similarly, the ip address for h2 is 192.168.1.2.

To test the communication between virtual hosts h1 and h2, first enter h1 on an open terminal, and ping\footnote{"ping" is a simple command-line utility to test connectivity between hosts. Additionally, "Ping" is often used as a verb.} \texttt{192.168.1.2}.
If the virtual network is functioning correctly, the ping should work, as seen in listing~\ref{lst:ping-h2}.

\begin{lstlisting}[style=ece361shell, caption={Pinging h2 from within h1.}, label={lst:ping-h2}]
ubuntu@ece361-h1:~/lab2$ ping -c 4 192.168.1.2
PING 192.168.1.2 (192.168.1.2) 56(84) bytes of data.
64 bytes from 192.168.1.2: icmp_seq=1 ttl=64 time=0.056 ms
64 bytes from 192.168.1.2: icmp_seq=2 ttl=64 time=0.060 ms
64 bytes from 192.168.1.2: icmp_seq=3 ttl=64 time=0.046 ms
64 bytes from 192.168.1.2: icmp_seq=4 ttl=64 time=0.076 ms

--- 192.168.1.2 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 2997ms
rtt min/avg/max/mdev = 0.046/0.059/0.076/0.013 ms
\end{lstlisting}

\hint{If you wish to exit the virtual host at any point, simply type \texttt{exit} on the command-line.}

%-------------------------------------------------------------------------------------------------
\subsection{Emulating Packet Loss}
%-------------------------------------------------------------------------------------------------
To see the effects of ARQ, we need an unreliable channel between the two virtual hosts.
To emulate packet loss, we have provided a script called \texttt{lab2-adjustLoss} which allows you to control the loss rate of packets entering a particular host.
For example, listing~\ref{lst:adjust-loss} shows how to set a packet loss rate of 10\% for packets entering h1.

\warn{The \texttt{lab2-adjustLoss} script will \textbf{not} work if the terminal is within a virtual host, so double-check your prompt.}

\begin{lstlisting}[style=ece361shell, caption={Emulating 10\% packet loss for packets entering h1.}, label={lst:adjust-loss}]
ubuntu@ece361:~/lab2$ ./lab2-adjustLoss h1 10%
\end{lstlisting}

To test the effect of the loss rate, we will use a tool called \texttt{iperf}.
With two terminals, enter h1 in one terminal, and enter h2 in the other.
In terminal h1, run an \texttt{iperf} server (the terminal will pause, waiting for a client to connect and send it data), as shown in listing~\ref{lst:iperf-server}.

\begin{lstlisting}[style=ece361shell, caption={Running an \texttt{iperf} server in h1.}, label={lst:iperf-server}]
ubuntu@ece361:~/lab2$ ./lab2-enterHost h1
ubuntu@ece361-h1:~/lab2$ iperf -s -u
------------------------------------------------------------
Server listening on UDP port 5001
Receiving 1470 byte datagrams
UDP buffer size:  208 KByte (default)
------------------------------------------------------------

\end{lstlisting}

In a second terminal, we enter h2 and run \texttt{iperf} client to send traffic to h1 at a rate of 100 Mbps.
Listing~\ref{lst:iperf-client} show the client in action with the end result highlighted, verifying the packet loss is being properly emulated.

\begin{lstlisting}[style=ece361shell, caption={Running an \texttt{iperf} client in h2.}, label={lst:iperf-client}]
ubuntu@ece361:~/lab2$ ./lab2-enterHost 2
ubuntu@ece361-h2:~/lab2$ iperf -c 192.168.1.1 -u -b 100M
------------------------------------------------------------
Client connecting to 192.168.1.1, UDP port 5001
Sending 1470 byte datagrams
UDP buffer size:  208 KByte (default)
------------------------------------------------------------
[  3] local 192.168.1.2 port 46722 connected with 192.168.1.1 port 5001
[ ID] Interval       Transfer     Bandwidth
[  3]  0.0-10.0 sec   120 MBytes   101 Mbits/sec
[  3] Sent 85471 datagrams
[  3] Server Report:
[  3]  0.0-10.0 sec   108 MBytes  90.5 Mbits/sec   0.001 ms (@"\btHL 8539/85470 (10\%)"@)
[  3]  0.0-10.0 sec  6 datagrams received out-of-order
\end{lstlisting}

After this test, you may kill the \texttt{iperf} server in the h1 terminal by pressing Ctrl+C.


%-------------------------------------------------------------------------------------------------
\section{Library Overview}
%-------------------------------------------------------------------------------------------------
In the last lab, you were asked to manually split a large file into smaller segments and send each individual segment by calling some socket API. In this lab, we have abstracted some of the low level details so you can use a set of higher level APIs that are easier to work with.
\figvs{0.8}{sender_class}{trim=0cm 0cm 0cm 0cm,clip}{Sender Class Hierarchy}
\figvs{0.8}{frame_class}{trim=0cm 0cm 0cm 0cm,clip}{Frame Class}

\subsection{Stop and Wait}
\subsubsection{Config File}


\subsubsection{Simple Stop and Wait}
We have implemented a stop and wait protocol similar to that of lab 1 that will work on an errorless channel. First set the following configuration:

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Configuration For Small File}]
{
    "sender_address": "192.168.1.2",
    "receiver_address": "192.168.1.1",
    "receiver_port": 6789,
    "arq_protocol": "stopandwait",
    "timeout": null,
    "frame_size": 1,
    "window_size": 2,
    "maxseqnum": 0
}
\end{lstlisting}
\end{minipage}

In this part we assume an errorless channel. Remove packet drop:
\begin{lstlisting}[language=bash]
$ sudo tc qdisc change dev veth0 root netem loss 0%
$ sudo tc qdisc change dev veth2 root netem loss 0%
\end{lstlisting}
Now run the following:

From the h1 terminal:
\begin{lstlisting}[language=bash]
$ python receiver.py received.txt
\end{lstlisting}
From the h2 terminal:
\begin{lstlisting}[language=bash]
$ python sender.py text_file_small.txt
\end{lstlisting}
Since the receiver is just a server that always listens to incoming packets, it does not know when the transmission ends. Therefore, you need to Ctrl-C the receiver before proceeding. This applies to all sections of the lab.
The sender should finish (If the sender doesn't exit by itself, Ctrl-C it). Verify that the file gets transmitted successfully:
\begin{lstlisting}[language=bash]
$ cat received.txt
I only have a few bytes.
\end{lstlisting}

\subsubsection {The \texttt{--}debug option}
We have provided you with a feature that prints out the progress on the sender and receiver frame by frame. This is very useful for later on for either debugging your code or just to understand how the protocol works. Try the following:

From the h1 terminal:
\begin{lstlisting}[language=bash]
$ python receiver.py --debug received.txt
\end{lstlisting}
From the h2 terminal:
\begin{lstlisting}[language=bash]
$ python sender.py --debug text_file_small.txt
\end{lstlisting}

Try understanding the debug message. It shouldn't be too hard since this is just a simple stop and wait and you implemented the same algorithm in lab 1. However, later on when the algorithm gets more complicated this will become more useful.

\subsection{Round Trip Time}
Now let's try a larger file. For larger files we need to increase the frame-size so the transmission doesn't take forever. Let's change the frame-size to 1024 (or 1K bytes):
\begin{lstlisting}[caption={Configuration For Large File}]
{
    "sender_address": "192.168.1.2",
    "receiver_address": "192.168.1.1",
    "receiver_port": 6789,
    "arq_protocol": "stopandwait",
    "timeout": null,
    "frame_size": 1024,
    "window_size": 2,
    "maxseqnum": 0
}
\end{lstlisting}
Run the following:

From the h1 terminal:
\begin{lstlisting}[language=bash]
$ python receiver.py received
\end{lstlisting}
From the h2 terminal:
\begin{lstlisting}[language=bash]
$ python sender.py binary_file_large
\end{lstlisting}

\warn{Do not use the '--debug' option when sending large files! The debug messages will flood your screen.}

Verify that the file get transmitted successfully, this time with a diff:
\begin{lstlisting}[language=bash]
$ diff binary_file_large received
\end{lstlisting}

Note that when the transmission ends the sender prints out some statistics:

\begin{lstlisting}[language=bash]
ARQ protocol: stopandwait
frames sent: 9106
frames delivered: 9106
transmission time: 0:00:03.292909
average rtt: 0:00:00
maximum rtt: 0:00:00
\end{lstlisting}

We have implemented the 'frames sent', 'frames delivered' and 'transmission time' statistics for you. We have left the rtt statistics for you to implement. Complete the class function \_update\_rtt in stopwaitsender.py, assuming a new frame just gets delivered with t\_send and t\_ack. You need to first calculated a new rtt sample based on t\_send and t\_ack and then update the rtt\_max and rtt\_total member variables. The rest of the calculations (e.g. average) has already been implemented for you. After you are done, rerun the previous binary\_file\_large experiment and make sure you get the rtt statistics printed out.

\subsection{Handling Frame Drop}
After you get the basic stop and wait working, enable frame drop from h2 to h1. Keep the channel from h1 to h2 errorless for now. For example, set the frame drop rate to 5\%:
\begin{lstlisting}[language=bash]
sudo tc qdisc change dev veth0 root netem loss 5%
\end{lstlisting}
Let's change the frame-size back to 1 for now:

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Configuration For Large File}]
{
    "sender_address": "192.168.1.2",
    "receiver_address": "192.168.1.1",
    "receiver_port": 6789,
    "arq_protocol": "stopandwait",
    "timeout": null,
    "frame_size": 1,
    "window_size": 2,
    "maxseqnum": 0
}
\end{lstlisting}
\end{minipage}
Rerun the 'text\_file\_small.txt with the '\texttt{--}debug' option. What is the result and why?
\subsubsection {Choosing a timeout}
In the previous experiment you saw that the prgram hang because if a frame is lost the sender would be waiting for the acknowledgement forever. To fix this, we need an appropriate timeout such that when the timer expires the sender retransmits the previous frame. Base on your rtt calculation in the previous section, change the "timeout" field of the config file from "null" to an appropriate value (Note: the unit is second, and floating point number is accepted)

\think{Should the timeout be based on the average or max rtt and why?}

\noindent Now rerun the 'text\_file\_small.txt' experiment and test if the transmission is successful.

\noindent After you get the small file working, change frame-size to 1024 and try transmitting binary\_file\_large.

\think{Can you figure a mathematical relationship between the expected frames sent, frames deliverd and the frame drop rate? Does the experimental result agree with your formula?}

\subsection {Handling Lost Ack}
Now let's enable frame lost from h1 to h2 as well.
\begin{lstlisting}[language=bash]
sudo tc qdisc change dev veth2 root netem loss 5%
\end{lstlisting}

Change the frame-size configuration back to 1:
\begin{lstlisting}[caption={Configuration For Large File}]
{
    "sender_address": "192.168.1.2",
    "receiver_address": "192.168.1.1",
    "receiver_port": 6789,
    "arq_protocol": "stopandwait",
    "timeout": <your choice>,
    "frame_size": 1,
    "window_size": 2,
    "maxseqnum": 0
}
\end{lstlisting}
Now rerun the text\_file\_small.txt experiment and examine the result. You should see something like this:

\begin{lstlisting}[language=bash]
$ cat received.txt
I only havee a few bytess.
\end{lstlisting}
The actual result varies from run to run, but the key here is duplicated frames. If you don't see duplicated frames then try again. If you still can't see it then you might want to increase the frame drop rate (e.g. from 5% to 10%).

To explain what happened, since the ack frame can be lost, the next frame the receiver received can either be a resend of the previous frame (due to lost ack) or a new frame (if ack successfully received by the sender). Without sequence numbers the receiver cannot distinguish betweeen these two cases. The sequence numbers are actually implemented already, you just need to enable it in the config. Set the "maxseqnum" field of the config file to any positive integer (e.g. 64).

\begin{lstlisting}[caption={Configuration For Large File}]
{
    "sender_address": "192.168.1.2",
    "receiver_address": "192.168.1.1",
    "receiver_port": 6789,
    "arq_protocol": "stopandwait",
    "timeout": <your choice>,
    "frame_size": 1,
    "window_size": 2,
    "maxseqnum": 64
}
\end{lstlisting}

Now rerun the 'text\_file\_small.txt' experiment and you should see that the file gets successfully transmitted (no more duplicated frames).

Finally, let's test the fully implemented stop and wait ARQ protocol on binary\_file\_large. Set the 'frame-size' back to 1024:

\begin{lstlisting}[caption={Configuration For Large File}]
{
    "sender_address": "192.168.1.2",
    "receiver_address": "192.168.1.1",
    "receiver_port": 6789,
    "arq_protocol": "stopandwait",
    "timeout": <your choice>,
    "frame_size": 1024,
    "window_size": 2,
    "maxseqnum": 64
}
\end{lstlisting}
From the h1 terminal:
\begin{lstlisting}[language=bash]
$ python receiver.py received
\end{lstlisting}
From the h2 terminal:
\begin{lstlisting}[language=bash]
$ python sender.py binary_file_large
\end{lstlisting}

\noindent You might need to wait for a while for the transmission to finish. Verify that the file gets transmitted successfully using diff.
\begin{lstlisting}[language=bash]
$ diff binary_file_large received
\end{lstlisting}

\noindent If the previous experiment succeeds, congratulations! You have a fully working stop and wait ARQ.

\section{Sliding Window ARQ (Send Many, Receive One)}

\subsection{Change the Config File to Use Sliding Window ARQ}
Change the "arq\_protocol" field of the config file from "stopandwait" to "slidingwindow". Make sure "window-size" is an integer greater than 1. Make sure "maxseqnum" is at least "window-size" (why?). Keep other parameters (e.g. timeout) the same as previous section:

\begin{lstlisting}[caption={Sliding Window Configuration}]
{
    "sender_address": "192.168.1.2",
    "receiver_address": "192.168.1.1",
    "receiver_port": 6789,
    "arq_protocol": "slidingwindow",
    "timeout": <your choice>,
    "frame_size": 1,
    "window_size": 2,
    "maxseqnum": 64
}
\end{lstlisting}

\think{If you set the window-size to be 1, what does the Sliding Window ARQ become?}

Try running the 'text\_file\_small.txt' experiment with '\texttt{--}debug' the same way as before:

\noindent From the h1 terminal:
\begin{lstlisting}[language=bash]
$ python receiver.py --debug received.txt
\end{lstlisting}
From the h2 terminal:
\begin{lstlisting}[language=bash]
$ python sender.py --debug text_file_small.txt
\end{lstlisting}

As you can see, the programs seem to be hanging without any debug outputs, which means no frame is being sent or received. This shouldn't surprise you since sliding window ARQ has not been implemented yet! Open the file slidingwindowsender.py and find the \_arqsend method. We have started the implementation for you by creating a send queue and your task is to complete the method. Apart from this method, the rest of the sender functions and the receiver are already implemented for you. We have given you some high level guidelines on what to do as well in the comments. Briefly go through the comments to have an idea of what needs to be done, but before you start coding, you must read the next section for a detailed description of our implementation of the sliding window protocol, which might differ in a few minor details from what you have learned.

\subsection{Protocol Description}
\figvs{0.4}{sw}{trim=0cm 0cm 0cm 0cm,clip}{Stop and Wait ARQ Timing Diagram}
\figvs{0.4}{sliding}{trim=0cm 0cm 0cm 0cm,clip}{Sliding Window ARQ Timing Diagram}
\figvs{0.4}{sliding_incorrect}{trim=0cm 0cm 0cm 0cm,clip}{Sliding Window ARQ Incorrect Implementation}

As you can see from Figure \ref{sw}, stop and wait ARQ is inefficient because the channel is idle during the period where the sender waits for acknowledgement from the receiver.
It would be much more efficient if the channel could be kept busy during this waiting period. This is where sliding window ARQ comes in, as illustrated in Figure \ref{sliding},
which demonstrates how sliding window works on a perfect, errorless channel.

\noindent A sliding window can be implemented on both the sender and the receiver side, but for this lab, we only consider sliding window on the sender side and the receiver still accepts one packet
at a time, similar to a stop and wait receiver. This makes our protocol behave like  ``send many, receive one''.

\noindent Note that one needs to make sure that the sliding window is implemented correctly. A typical incorrect implementation is illustrated in Figure \ref{sliding_incorrect}
where frames 1, 2 and 3 should not be resent.

\figvs{0.4}{sliding_error}{trim=0cm 0cm 0cm 0cm,clip}{Sliding Window ARQ Error Control}

\subsubsection{Error Control}
The most basic error control mechanisims in sliding window ARQ are acknowledgement and timeout, much like stop and wait. Upon receiving the frame with the correct sequence number,
the receiver sends back an ACK with the next sequence number. The acknowledgements are independently sent to every frame. Each frame also has a timer which starts right after the 
frame is sent. If, after some timeout period the frame does not receive its corresponding ACK, the frame is retransmitted. As illustrated in Figure \ref{sliding_error}, frame 0 is retransmitted after
sometimeout period.

\figvs{0.4}{ack_multi}{trim=0cm 0cm 0cm 0cm,clip}{Culmulative ACK}
Consider the case in Figure \ref{ack_multi}. Frames 0,1,2,3 all transmitted successfully but the ACKs are all lost. From the senders point of view there is no difference to the case where the frames
are lost so frame 0 is retransmitted. When the receiver receives frame 0, it should send an acknowledgements for frames 0, 1, 2 and 3 since those frames have all been received. However, a more 
bandwidth efficient way is to use what is called a "culmulative ack", which the receiver only sends an ACK for frame 3 (ACK 4), which implies that frames 0, 1, 2 3 have all been received, and the sender
can immediately start sending frame 4, as illustrated in the figure. Note that if the sender does not know about culmulative acks it won't be able to talk to the receiver correctly.

\figvs{0.4}{ack_multi_handle}{trim=0cm 0cm 0cm 0cm,clip}{Culmulative ACK Handling}
In very much exactly the same way, if an ACK for a certain frame is received it is implied that all frames earlier than that frame are received, even if their ACKs don't arrive, as illustrated in Figure
\ref{ack_multi_handle}. Upon receiving the ACK, the sender can immediately start transmitting the next frame.

\figvs{0.4}{ack_multi_handle2}{trim=0cm 0cm 0cm 0cm,clip}{Culmulative ACK Handling Alternative}
There is an implementation detail on what the sender should do upon receiving a culmulative ack in half way through transmitting the send window. The best implementation is of course that in Figure \ref{ack_multi_handle}, where
the sender aborts the current send window and immediately start sending the frame with the correct sequence number. However, this is sometimes hard to implement. Therefore, in this lab you will do a simpler but less efficient implementation
as illustrated in Figure \ref{ack_multi_handle2}, where the sender is allowed to finish the current send window and then starts sending the correct frame. This is less efficient due to extra duplicated frames being
sent, but easier to implement.

\figvs{0.4}{nack}{trim=0cm 0cm 0cm 0cm,clip}{Out of Order Frames and NACKs}
Finally, there is one last case we need to cover, which is out of order frames. As illustrated in Figure \ref{nack}, frames 0 is lost, so frames 1, 2, 3 are out of order so the receiver rejects the frame
and sends a NACK for the sequence number of the correct frame, in this case, frame 0. In our implementation, NACKs are always sent for out of order frames.

\noindent Note that the NACK here in this lab might not be what you think it is. It is just called NACK to distinguish it from an ACK. Implementation-wise there is no difference between a NACK and a resend
of the ``ACK'' for the last received frame. So to some extent NACKs in our context is no different than cumulative ACKs except that it is sending ACKs for frames in the past instead of frames in the future.
In real life, however, NACKs may be really 'NACKs' indicating that the there is something wrong with the frame (e.g. corruption), but you don't have to worry about that in this lab. You can assume that
if a  frame arrives at the receiver it always arrives without error.

\think{If we do not send any NACKs, does the sliding window ARQ still work? If the answer is yes, what mechanism will it rely on for the sender to know to re-transmit the correct frame and why are NACKs useful then?}

\subsection{Implement the Sliding Window ARQ}
Based on what you've learnt far, implement the '\_arq\_send' function in 'slidingwindowsender.py'. During the debugging stage, it is recommended to test transmitting "text\_file\_small.txt" with "frame-size" 1 and "--debug" on. (However, the DEBUG messages on the sender side needs to be implemented by you). After testing your code on the small test case, test sending the binary\_file\_large file using a frame-size of 1024 and 5\% channel loss both direction. After the transmission is done, use the diff command to make sure that the file is transmitted successfully.

\hint{If you get stuck, go back to take a look at client\_improved.py in the example directory and understand it in detail. A lot of the ideas used in that progam are directly applicable to implementing sliding window ARQ.}


\subsection{Getting the Optimal Transmission Time}

Start with the following configuration:
\begin{lstlisting}[caption={Sliding Window Configuration}]
{
    "sender_address": "192.168.1.2",
    "receiver_address": "192.168.1.1",
    "receiver_port": 6789,
    "arq_protocol": "slidingwindow",
    "timeout": <your choice>,
    "frame_size": 1024,
    "window_size": 2,
    "maxseqnum": 64
}
\end{lstlisting}

First set the window size to 2. Do you see an improved performance compared to Stop and Wait? If you keep increasing the window size, what do you see? Can you explain why?

\section{Cleanup}
After finishing the lab, please run:
\begin{lstlisting}[language=bash]
$ sudo sh setup_scripts/lab2_cleanup.sh
\end{lstlisting}

%-------------------------------------------------------------------------------------------------
\section{Exerciser}
\label{sec:exercise}
%-------------------------------------------------------------------------------------------------
You can use the exerciser to help test the correctness of your implementation. The exerciser will run a set of public test cases against your code.
Ensure you have the following files all within the same directory:
\begin{itemize}
    \item \textbf{stopandwaitsender.py}: Your completed stop-and-wait sender code from section~\textbf{TODO}.
    \item \textbf{slidingwindowsender.py}: Your completed sliding window sender code from section~\textbf{TODO}.
\end{itemize}

In terminal, browse to the directory containing the files and type \texttt{ece361-exercise \thelab}.


%-------------------------------------------------------------------------------------------------
\section{Submission}
\label{sec:submission}
%-------------------------------------------------------------------------------------------------
Once you are confident of your implementation, you can run the submission process (which will invoke the exerciser before submitting).
Only one person in the group needs to submit.

From the same directory as where you ran the exerciser, type \texttt{ece361-submit submit \thelab}.

You can then verify the submission by typing \texttt{ece361-submit list \thelab}.

At some point after the lab's due date, private test cases will be run against your submission to calculate your final mark.


\end{document}
